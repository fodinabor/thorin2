// RUN: rm -f %t.ll ; \
// RUN: %thorin -d affine -d direct %s --output-thorin - --output-ll %t.ll | FileCheck %s
// RUN: clang %t.ll -o %t -Wno-override-module

.import affine;
.import mem;
.import core;

.let i32 = %Int 4294967296;
.cn .extern main [mem : %mem.M, argc : i32, argv : %mem.Ptr (%mem.Ptr (i32, 0:.Nat), 0:.Nat), return : .Cn [%mem.M, i32]] = {
    // .let arr_size = 16;
    .let arr_size = %core.bitcast (.Nat, i32) argc;
    .let arr = <arr_size ; 0:(i32)>;
    .let arr2 = .ins (arr, 1:(%Int arr_size), 7:(i32));
    .cn for_exit [mem : %mem.M , acc : [i32, i32, <<arr_size; i32>>]] = {
        .let idx = %core.conv.u2u (arr_size, 4294967296) (%core.wrap.sub (0, 4294967296) (argc, 4:i32));
        return (mem, acc#2:(%Int 3)#idx)
    };
    .cn for_body [mem : %mem.M , i : i32, acc : [i32, i32, <<arr_size; i32>>], continue : .Cn [%mem.M , [i32, i32, <<arr_size; i32>>]]] = {
        .let a : i32 = %Wrap_add (0:.Nat, 4294967296:.Nat) (i, acc#0:(%Int 3));
        .let b : i32 = %Wrap_sub (0:.Nat, 4294967296:.Nat) (i, acc#1:(%Int 3));
        .let arr2 = .ins (acc#2:(%Int 3), %core.conv.u2u (arr_size, 4294967296) i, a);
        continue (mem, (a, b, arr2))
    };
    // .cn for2 [mem : %mem.M , acc : [i32, i32, <<arr_size; i32>>]] = {
    //     %affine.For (4294967296, 3, (i32, i32, <<arr_size; i32>>)) (mem, 0:(i32), argc, 1:(i32), (acc#0:(%Int 3), acc#1:(%Int 3), arr), for_body, for_exit)
    // };
    %affine.For (4294967296, 3, (i32, i32, <<arr_size; i32>>)) (mem, 0:(i32), argc, 1:(i32), (0:(i32), 0:(i32), arr2), for_body, for_exit)
};

.cn .extern main2 [mem : %mem.M, argc : i32, argv : %mem.Ptr (%mem.Ptr (i32, 0:.Nat), 0:.Nat), return : .Cn [%mem.M, i32]] = {
    .let arr_size = %core.bitcast (.Nat, i32) argc;
    .let idx = %core.conv.u2u (arr_size, 4294967296) (%core.wrap.sub (0, 4294967296) (argc, 4:[%Int 4294967296]));
    .let arr = <arr_size ; 0:(i32)>;
    .let arr_1 = <arr_size ; 1:(i32)>;
    .let arr0 = .ins (arr, 1:(%Int arr_size), 7:(i32));
    .let arr1 = .ins (arr_1, 5:(%Int arr_size), 7:(i32));
    return (mem, %core.wrap.add(0, 4294967296) (arr0#idx, arr1#idx))
};

// CHECK-LABEL: .cn .extern main2

// CHECK-DAG: %mem.malloc
// CHECK-DAG: %mem.lea
// CHECK-DAG: %mem.store

// CHECK-DAG: %mem.malloc
// CHECK-DAG: %mem.lea
// CHECK-DAG: %mem.store

// CHECK-DAG: %mem.malloc
// CHECK-DAG: %mem.lea
// CHECK-DAG: %mem.load
// CHECK-DAG: %mem.lea
// CHECK-DAG: %mem.store

// CHECK-DAG: %mem.lea
// CHECK-DAG: %mem.store

// CHECK-DAG: %mem.malloc
// CHECK-DAG: %mem.lea
// CHECK-DAG: %mem.load
// CHECK-DAG: %mem.lea
// CHECK-DAG: %mem.store

// CHECK-DAG: %mem.lea
// CHECK-DAG: %mem.store

.cn .extern reverse [mem: %mem.M, size: .Nat, idx0: %Int size, idx1: %Int size, idx2: %Int size, return : .Cn [%mem.M, i32]] = {
   .let arr = <size ; 0:i32>;
   .let arr2 = .ins (arr, idx0, 7:i32);
   .let arr3 = .ins (arr2, idx1, 7:i32);
   return (mem, arr2#(%core.conv.u2u (size, 4294967296) arr3#idx2))
};

// CHECK-LABEL: .cn .extern reverse
// CHECK-DAG: %mem.malloc

