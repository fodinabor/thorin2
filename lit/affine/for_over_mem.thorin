// RUN: rm -f %t.ll ; \
// RUN: %thorin -d affine %s --output-ll %t.ll --output-thorin - | FileCheck %s
// RUN: clang %t.ll -o %t -Wno-override-module
// RUN: %t 0 1 2 3 ; test $? -eq 1
// RUN: %t 0 1 2 3 4 5 6 7 ; test $? -eq 15

.import affine;
.import mem;
.import core;

.let i32 = %Int 4294967296;

.cn .extern main [mem : %mem.M, argc : i32, argv : %mem.Ptr (%mem.Ptr (i32, 0:.Nat), 0:.Nat), return : .Cn [%mem.M, i32]] = {
    // .let arr_size = 16;
    .let arr_size = ⊤:.Nat;
    .let (alloc_mem, ptr) = %mem.alloc (<<%core.bitcast (.Nat, i32) argc; i32>>, 0) (mem);
    .cn for_exit [mem_exit : %mem.M, i32, i32] = {
        .let lea = %mem.lea (arr_size, <arr_size; i32>, 0) (ptr, %core.conv.u2u (arr_size, 4294967296) (%core.wrap.sub (0, 4294967296) (argc, 4:i32)));
        .let (load_mem, val) = %mem.load (i32, 0) (mem_exit, lea);
        return (load_mem, val)
    };
    .cn for_body [i : i32, [mem_body : %mem.M, acc_a : i32, acc_b : i32], continue : .Cn [%mem.M, i32, i32]] = {
        .let a : i32 = %core.wrap.add (0:.Nat, 4294967296:.Nat) (i, acc_a);
        .let b : i32 = %core.wrap.sub (0:.Nat, 4294967296:.Nat) (i, acc_b);
        .let lea = %mem.lea (arr_size, <arr_size; i32>, 0) (ptr, %core.conv.u2u (arr_size, 4294967296) i);
        .let store_mem = %mem.store (i32, 0) (mem_body, lea, a);
        continue (store_mem, a, b)
    };
    %affine.For (4294967296, 3, (%mem.M, i32, i32)) (0:(i32), argc, 1:(i32), (alloc_mem, 0:(i32), 0:(i32)), for_body, for_exit)
};

// CHECK-NOT: affine.For


//.import affine;
//.import core;
//.import direct;
//.import mem;
//
//
//
//.cn .extern main __257034::[mem_257104: %mem.M, argc_257038: (%Int 4294967296), %mem.Ptr (%mem.Ptr ((%Int 4294967296), 0:.Nat), 0:.Nat), return_257362: .Cn [%mem.M, (%Int 4294967296)]] = {
//
//    .let _257075: .Nat = %core.bitcast (.Nat, (%Int 4294967296)) argc_257038;
//    .let _257105: [%mem.M, %mem.Ptr («_257075; (%Int 4294967296)», 0:.Nat)] = %mem.alloc («_257075; (%Int 4294967296)», 0:.Nat) mem_257104;
//    .let _257407: (%Int 4294967296) = %core.wrap.add (0:.Nat, 4294967296:.Nat) (4294967292:(%Int 4294967296), argc_257038);
//    .let _257408: %Int ⊤:.Nat = %core.conv.u2u (⊤:.Nat, 4294967296:.Nat) _257407;
//    .let _257418: %mem.Ptr ((%Int 4294967296), 0:.Nat) = %mem.lea (⊤:.Nat, ‹⊤:.Nat; (%Int 4294967296)›, 0:.Nat) (_257105#1:(%Int 2), _257408);
//    .cn _260522 _260758: [] = {
//        .let _257426: [%mem.M, (%Int 4294967296)] = %mem.load ((%Int 4294967296), 0:.Nat) (_257105#0:(%Int 2), _257418);
//        .let _257427: ⊥:★ = return_257362 _257426;
//        _257427
//    };
//
//    .cn for_260490 _260492::[_260498: (%Int 4294967296), _260504: %mem.M, _260510: (%Int 4294967296), _260516: (%Int 4294967296)] = {
//
//        .cn for_body_260528 _260759: [] = {
//            .let _260542: (%Int 4294967296) = %core.wrap.add (0:.Nat, 4294967296:.Nat) (1:(%Int 4294967296), _260498);
//            .let _260547: %Int ⊤:.Nat = %core.conv.u2u (⊤:.Nat, 4294967296:.Nat) _260498;
//            .let _260557: %mem.Ptr ((%Int 4294967296), 0:.Nat) = %mem.lea (⊤:.Nat, ‹⊤:.Nat; (%Int 4294967296)›, 0:.Nat) (_257105#1:(%Int 2), _260547);
//            .let _260562: (%Int 4294967296) = %core.wrap.add (0:.Nat, 4294967296:.Nat) (_260498, _260510);
//            .let _260569: %mem.M = %mem.store ((%Int 4294967296), 0:.Nat) (_260504, _260557, _260562);
//            .let _260574: (%Int 4294967296) = %core.wrap.sub (0:.Nat, 4294967296:.Nat) (_260498, _260516);
//            .let _260931: ⊥:★ = for_260490 (_260542, _260569, _260562, _260574);
//            _260931
//        };
//        .let _260582: (%Int 2) = %core.icmp.XygLe 4294967296:.Nat (_260498, argc_257038);
//        .let _260584: ⊥:★ = (_260522, for_body_260528)#_260582 ();
//        _260584
//    };
//    .let _260591: ⊥:★ = for_260490 (0:(%Int 4294967296), _257105#0:(%Int 2), 0:(%Int 4294967296), 0:(%Int 4294967296));
//    _260591
//};
//